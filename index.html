<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binance USDT-Perp Market Psychology Detector</title>
  <style>
    body{font-family:Inter,system-ui,Arial; background:#0f1720;color:#e6eef8;margin:12px}
    .card{background:#081028;border-radius:8px;padding:12px;margin:8px 0}
    table{width:100%;border-collapse:collapse}
    th,td{padding:6px;border-bottom:1px solid rgba(255,255,255,0.04);text-align:left;font-size:13px}
    th{opacity:0.8}
    .chip{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px}
    .acc{background:#083f1f;color:#a8f0bb}
    .dist{background:#4a0f0f;color:#ffc6c6}
    .markup{background:#08305a;color:#bcd7ff}
    .markdown{background:#3a2a00;color:#ffe9a3}
    .sideways{background:#2a2a2a;color:#cfd8e3}
    .status{margin-top:8px;font-size:13px}
    input,select{padding:6px;margin-right:6px}
    .warn{color:#ffd28a;font-size:13px;margin-top:6px}
  </style>
</head>
<body>
  <h2>Binance USDT-Perp Market Psychology Detector</h2>

  <div class="card">
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <label>Timeframe:
        <select id="tf"><option>1m</option><option>5m</option><option>15m</option><option>1h</option><option>4h</option><option>1d</option></select>
      </label>
      <label>Batch size (symbols / websocket):
        <input type="number" id="batchSize" value="40" min="5" max="800"/>
      </label>
      <label>Klines to fetch for rules:
        <input type="number" id="lookback" value="100" min="20" max="2000"/>
      </label>
      <button id="start">Start</button>
      <button id="stop">Stop</button>
    </div>
    <div class="status" id="status">Idle</div>
    <div class="warn" id="warn" style="display:none"></div>
  </div>

  <div class="card" id="controls" style="display:block">
    <div style="margin-bottom:8px">Detected symbols (<span id="count">0</span>)</div>
    <div style="max-height:60vh;overflow:auto">
      <table id="table"><thead><tr><th>Symbol</th><th>Price</th><th>Phase</th><th>Reason</th></tr></thead><tbody></tbody></table>
    </div>
  </div>

  <script>
  const API_BASE = 'https://fapi.binance.com';
  let running = false;
  let symbols = [];
  let sockets = [];
  let state = {};

  function setStatus(s){ document.getElementById('status').innerText = s }
  function showWarn(s){ const w=document.getElementById('warn'); w.style.display = s ? 'block':'none'; w.innerText = s || '' }

  async function fetchExchangeInfo(){
    setStatus('Fetching exchange info...');
    const resp = await fetch(API_BASE + '/fapi/v1/exchangeInfo');
    if(!resp.ok) throw new Error('exchangeInfo failed: '+resp.status);
    const js = await resp.json();
    const usdt = js.symbols.filter(s=> (s.contractType || s.isSpot !== undefined) && (s.symbol.endsWith('USDT') || s.quoteAsset==='USDT'));
    return usdt.map(s=>s.symbol);
  }

  // indicators
  function sma(arr, n){ if(arr.length<n) return null; const slice=arr.slice(-n).map(Number); return slice.reduce((a,b)=>a+b,0)/n }
  function stddev(arr, n){ if(arr.length<n) return null; const slice=arr.slice(-n).map(Number); const m=sma(slice,n); const v=slice.reduce((a,b)=>a+Math.pow(b-m,2),0)/n; return Math.sqrt(v) }
  function atr(highs,lows,closes,n=14){
    if(closes.length<n) return null;
    let trs=[];
    for(let i=1;i<closes.length;i++){
      const tr = Math.max(Math.abs(Number(highs[i]) - Number(lows[i])), Math.abs(Number(highs[i]) - Number(closes[i-1])), Math.abs(Number(lows[i]) - Number(closes[i-1])));
      trs.push(tr);
    }
    const last = trs.slice(-n);
    const sum = last.reduce((a,b)=>a+b,0);
    return sum / n;
  }

  function detectPhase(klines){
    if(!Array.isArray(klines) || klines.length<30) return {phase:'unknown',reason:'insufficient data'};
    // klines from Binance: [ openTime, open, high, low, close, volume, ... ]
    const closes = klines.map(k=>Number(k[4]));
    const highs = klines.map(k=>Number(k[2]));
    const lows = klines.map(k=>Number(k[3]));
    const vols  = klines.map(k=>Number(k[5]));
    const sma20 = sma(closes,20);
    const sma50 = sma(closes,50);
    const volRecent = sma(vols,5);
    const volPast = sma(vols,30);
    const sd20 = stddev(closes,20);
    const atr14 = atr(highs,lows,closes,14);
    const last = closes[closes.length-1];
    const prev = closes[Math.max(0,closes.length-6)];
    const slope = prev !== 0 ? (last - prev)/prev : 0;

    // compression: low volatility relative to price (tweakable)
    const compression = (atr14 && (atr14/last) < 0.006) || (sd20 && (sd20/last) < 0.004);
    const volRising = volRecent && volPast && (volRecent > volPast*1.15);
    const volFalling = volRecent && volPast && (volRecent < volPast*0.85);

    // rules (prototype)
    if(compression && volRising && slope>0) return {phase:'Accumulation', reason:'low volatility + volume rising + slight upward bias'};
    if(compression && volFalling && slope<=0) return {phase:'Distribution', reason:'low volatility + volume falling + no upward bias'};
    if(slope>0.02 || (sma20 && sma50 && sma20 > sma50)) return {phase:'Markup', reason:'strong upward momentum / above mid-term avg'};
    if(slope<-0.02 || (sma20 && sma50 && sma20 < sma50)) return {phase:'Markdown', reason:'strong downward momentum / below mid-term avg'};

    if(sma20 && sma50){
      if(sma20 > sma50) return {phase:'Markup', reason:'price above mid-term average'};
      if(sma20 < sma50) return {phase:'Markdown', reason:'price below mid-term average'};
    }

    return {phase:'Sideways', reason:'no clear momentum or compression signals'};
  }

  async function safeFetchKlines(symbol, interval, limit=100){
    const url = `${API_BASE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
    let tries=0;
    while(tries<5){
      try{
        const resp = await fetch(url);
        if(resp.status===429 || resp.status===418){
          const wait = (Math.pow(2,tries)+1)*1000;
          console.warn('rate limited, backing off',wait);
          await new Promise(r=>setTimeout(r,wait));
          tries++; continue;
        }
        if(!resp.ok) throw new Error('klines failed:'+resp.status);
        return await resp.json();
      }catch(e){
        console.error('klines fetch error',e);
        const wait = (Math.pow(2,tries)+1)*1000;
        await new Promise(r=>setTimeout(r,wait));
        tries++;
      }
    }
    throw new Error('klines fetch failed after retries');
  }

  function addRow(symbol, price, phase, reason){
    const tbody = document.querySelector('#table tbody');
    let row = document.getElementById('r-'+symbol);
    if(!row){ row = document.createElement('tr'); row.id = 'r-'+symbol; row.innerHTML = `<td>${symbol}</td><td class="price"></td><td class="phase"></td><td class="reason"></td>`; tbody.appendChild(row); }
    row.querySelector('.price').innerText = price;
    const pcell = row.querySelector('.phase');
    pcell.innerText = phase;
    pcell.className = 'phase chip ' + (phase.toLowerCase().replace(/\s+/g,''));
    row.querySelector('.reason').innerText = reason;
  }

  async function start(){
    if(running) return; running=true; setStatus('Starting...');
    const tf = document.getElementById('tf').value;
    const batchSize = Math.max(5, Math.min(800, parseInt(document.getElementById('batchSize').value,10)||40));
    const lookback = Math.max(20, parseInt(document.getElementById('lookback').value,10)||100);

    showWarn('');

    try{
      symbols = await fetchExchangeInfo();
    }catch(e){
      setStatus('Error fetching exchangeInfo: '+e.message);
      running=false; return;
    }

    document.getElementById('count').innerText = symbols.length;
    setStatus('Got '+symbols.length+' symbols. Preparing batches...');

    const batches = [];
    for(let i=0;i<symbols.length;i+=batchSize) batches.push(symbols.slice(i,i+batchSize));

    // safety: warn if many connections/batches (connection attempt limits)
    if(batches.length > 250){
      showWarn('Large number of batches ('+batches.length+'). You may hit the connection attempt limits (300 attempts / 5 minutes). Consider increasing batchSize or running a server-side aggregator.');
    }

    setStatus('Fetching historical klines (staggered). This may take some time.');
    for(let i=0;i<symbols.length;i++){
      const sym = symbols[i];
      try{
        // stagger 200ms per symbol (conservative)
        await new Promise(r=>setTimeout(r,200));
        const klines = await safeFetchKlines(sym, tf, Math.min(lookback,100));
        const det = detectPhase(klines);
        const price = klines[klines.length-1][4];
        state[sym] = {klines, phase:det.phase, reason:det.reason, price};
        addRow(sym, price, det.phase, det.reason);
      }catch(e){
        console.warn('hist fail',sym,e);
        addRow(sym,'-','error','history fetch failed');
      }
    }

    setStatus('Connecting websockets in '+batches.length+' batches...');

    for(let b=0;b<batches.length && running;b++){
      const list = batches[b];
      const streams = list.map(s=>s.toLowerCase()+'@kline_'+tf).join('/');
      const url = `wss://fstream.binance.com/stream?streams=${streams}`;
      // delay between opening connections to avoid storms
      await new Promise(r=>setTimeout(r,500*(b%3+1)));

      try{
        const ws = new WebSocket(url);
        sockets.push(ws);
        ws.onopen = ()=>console.log('ws open',b,list.length);
        ws.onmessage = (ev)=>{
          try{
            const data = JSON.parse(ev.data);
            const payload = data.data || data;
            if(payload && payload.k){
              const k = payload.k;
              const sym = k.s;
              const close = k.c;
              if(state[sym] && state[sym].klines){
                // keep minimal fields to match original binance structure
                state[sym].klines.push([k.t, k.o, k.h, k.l, k.c, k.v]);
                if(state[sym].klines.length>200) state[sym].klines.shift();
                const det = detectPhase(state[sym].klines);
                state[sym].phase = det.phase; state[sym].reason = det.reason; state[sym].price = close;
                addRow(sym, close, det.phase, det.reason);
              } else {
                // create a minimal state if missing
                state[sym] = {klines:[[k.t, k.o, k.h, k.l, k.c, k.v]], phase:'unknown', reason:'streamed'};
                addRow(sym, k.c, 'unknown','streamed only');
              }
            }
          }catch(e){ console.error('ws message parse',e) }
        };
        ws.onerror = (e)=>console.warn('ws err',e);
        ws.onclose = ()=>console.log('ws closed',b);
      }catch(e){
        console.warn('ws connection fail',e);
      }
    }

    setStatus('Running — live updates active. Watch the table. (Note: watch for 429/418 or websocket disconnects)');
  }

  function stop(){ running=false; setStatus('Stopping — closing sockets'); sockets.forEach(s=>{ try{s.close()}catch(e){} }); sockets=[] }

  document.getElementById('start').addEventListener('click', ()=>start().catch(e=>setStatus('Error: '+e.message)));
  document.getElementById('stop').addEventListener('click', ()=>stop());
  </script>
</body>
</html>
