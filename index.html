<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Perp Consolidation Detector — Binance Futures (USDT)</title>
  <style>
    body{font-family:Inter, Roboto, Arial; background:#0f1720; color:#e6eef8; margin:12px}
    .card{background:#0b1220;border-radius:10px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,0.5);max-width:980px}
    label,input,button,select{font-size:14px}
    input,select{padding:6px;margin-right:6px;background:#071021;border:1px solid #172033;color:#d6e7ff;border-radius:6px}
    button{padding:8px 10px;border-radius:8px;border:none;background:#1f8cff;color:#fff;cursor:pointer}
    .log{background:#06121a;padding:8px;border-radius:6px;margin-top:10px;min-height:120px;overflow:auto}
    .signal{padding:8px;border-radius:6px;margin-top:8px}
    .signal.ok{background:#08331a;color:#a6f7be}
    .signal.warn{background:#3a2a0f;color:#ffd9a5}
    .signal.bad{background:#3a0f0f;color:#ffbdbd}
    .status{margin-left:8px;font-size:13px;color:#94a3b8}
    .row{display:flex;align-items:center;gap:6px;flex-wrap:wrap}
    .meta{margin-top:8px;color:#94a3b8;font-size:13px}
    .status-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle}
    .status-running{background:#22c55e}
    .status-stopped{background:#ef4444}
    .status-idle{background:#94a3b8}
    .small{font-size:12px;color:#9fb5d6}
  </style>
</head>
<body>
  <div class="card">
    <h2>Perp Consolidation & Breakout Detector (HTML)</h2>
    <p>Connects to Binance Futures WebSocket for <strong>symbol</strong> + <strong>interval</strong>, detects consolidation and signals breakout with volume confirmation.</p>

    <div class="row">
      <label>Symbol</label>
      <input id="symbol" value="btcusdt" />
      <label>Interval</label>
      <select id="interval">
        <option value="1m">1m</option>
        <option value="3m">3m</option>
        <option value="5m" selected>5m</option>
        <option value="15m">15m</option>
        <option value="1h">1h</option>
      </select>
      <label>Lookback</label>
      <input id="lookback" value="24" style="width:64px" />
      <label>StdTh</label>
      <input id="stdTh" value="0.004" style="width:80px" />
      <button id="start">Start</button>
      <button id="stop">Stop</button>
    </div>

    <div class="meta">
      <span id="wsUrl" class="small"></span>
      <div style="margin-top:6px">
        <span class="status-dot status-idle" id="statusDot"></span>
        <span id="statusText" class="small">idle</span>
      </div>
    </div>

    <div style="margin-top:10px">
      <strong>How it works (defaults):</strong>
      <ul>
        <li>Collects `lookback` kline candles (close, high, low, volume).</li>
        <li>Consolidation detected when close-price std dev relative to mean &lt; <code>stdTh</code> and ATR small and EMA spread compressed.</li>
        <li>Breakout confirmed when price closes above consolidation resistance and volume &gt; volumeMA * 1.5.</li>
      </ul>
    </div>

    <div class="log" id="log"></div>
    <div id="signals"></div>
  </div>

<script>
// Diagnostics first: helpful messages to UI + console
(function(){
  const logEl = document.getElementById('log');
  const signalsEl = document.getElementById('signals');
  const wsUrlEl = document.getElementById('wsUrl');
  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');

  let ws = null;
  let running = false;

  function now(){ return new Date().toLocaleTimeString(); }
  function uiLog(msg){
    logEl.innerHTML = `<div>[${now()}] ${msg}</div>` + logEl.innerHTML;
    console.log(`[Detector] ${msg}`);
  }
  function setSignal(msg, level='ok'){
    const el = document.createElement('div');
    el.className = `signal ${level}`;
    el.textContent = `${now()} — ${msg}`;
    signalsEl.prepend(el);
    console.log(`[Signal:${level}] ${msg}`);
  }
  function setStatus(text, cls='idle'){
    statusText.textContent = text;
    statusDot.className = 'status-dot ' + (cls==='running'? 'status-running' : cls==='stopped' ? 'status-stopped' : 'status-idle');
  }

  // Small helpers (same logic as before)
  function ema(values, period){
    if(!Array.isArray(values) || values.length===0) return null;
    const k = 2/(period+1);
    let emaPrev = values[0];
    for(let i=1;i<values.length;i++) emaPrev = values[i]*k + emaPrev*(1-k);
    return emaPrev;
  }
  function atr(candles, period=14){
    if(!candles || candles.length<=1) return 0;
    let trs=[];
    for(let i=1;i<candles.length;i++){
      const high = parseFloat(candles[i].h);
      const low = parseFloat(candles[i].l);
      const prevClose = parseFloat(candles[i-1].c);
      const tr = Math.max(high-low, Math.abs(high-prevClose), Math.abs(low-prevClose));
      trs.push(tr);
    }
    if(trs.length === 0) return 0;
    const sub = trs.slice(-period);
    return sub.reduce((a,b)=>a+b,0)/sub.length;
  }
  function detectConsolidation(candles, stdTh=0.004){
    const closes = candles.map(c=>parseFloat(c.c));
    const mean = closes.reduce((a,b)=>a+b,0)/closes.length;
    const diffs = closes.map(v=>v-mean);
    const variance = diffs.reduce((a,b)=>a+b*b,0)/closes.length;
    const std = Math.sqrt(variance);
    const relativeStd = std/mean;
    const myAtr = atr(candles, Math.min(14, candles.length-1));
    const relativeAtr = myAtr/mean;
    const shortE = ema(closes.slice(-10), 5);
    const longE = ema(closes.slice(-20), 10) || shortE;
    const emaSpread = Math.abs(shortE-longE)/mean;
    const isStdTight = relativeStd < stdTh;
    const isAtrLow = relativeAtr < Math.max(stdTh*1.5, 0.005);
    const isEmaCompressed = emaSpread < stdTh*1.5;
    return { consolidation: isStdTight && isAtrLow && isEmaCompressed, relativeStd, relativeAtr, emaSpread, mean, std };
  }
  function rangeFromCandles(candles){
    const highs = candles.map(c=>parseFloat(c.h));
    const lows = candles.map(c=>parseFloat(c.l));
    return {res: Math.max(...highs), sup: Math.min(...lows)};
  }
  function volMA(candles, n=20){
    if(!candles || candles.length===0) return 0;
    const vols = candles.map(c=>parseFloat(c.v));
    const sub = vols.slice(-n);
    return sub.reduce((a,b)=>a+b,0)/sub.length;
  }

  // Start/Stop logic
  function start(){
    if(running){
      uiLog('Already running');
      return;
    }
    const symbol = (document.getElementById('symbol').value || 'btcusdt').toLowerCase();
    const interval = document.getElementById('interval').value || '5m';
    const lookback = parseInt(document.getElementById('lookback').value)||24;
    const stdTh = parseFloat(document.getElementById('stdTh').value)||0.004;

    const wsUrl = `wss://fstream.binance.com/ws/${symbol}@kline_${interval}`;
    wsUrlEl.textContent = `WS URL: ${wsUrl}`;
    uiLog(`Starting detector for ${symbol}@${interval} (lookback ${lookback})`);
    setStatus('connecting', 'idle');

    try{
      ws = new WebSocket(wsUrl);
    }catch(err){
      uiLog('WebSocket construction failed: ' + err.message);
      setStatus('stopped','stopped');
      return;
    }

    const candles = [];

    ws.onopen = function(){
      running = true;
      uiLog('WS OPEN');
      setStatus('running', 'running');
    };

    ws.onerror = function(evt){
      console.error('WS ERROR', evt);
      uiLog('WebSocket error (check console).');
      setStatus('stopped','stopped');
    };

    ws.onclose = function(ev){
      uiLog(`WS CLOSED (code ${ev.code})`);
      running = false;
      setStatus('stopped','stopped');
    };

    ws.onmessage = function(evt){
      try{
        const d = JSON.parse(evt.data);
        if(!d.k) return;
        const k = d.k;
        const candle = {t:k.t, o:k.o, h:k.h, l:k.l, c:k.c, v:k.v, isFinal:k.x};

        if(candles.length===0 || candles[candles.length-1].t !== candle.t) {
          candles.push(candle);
          if(candles.length>500) candles.shift();
        } else {
          candles[candles.length-1] = candle;
        }

        // analyze only closed candles
        if(!candle.isFinal) return;

        if(candles.length < lookback){
          uiLog(`collected ${candles.length}/${lookback} closed candles`);
          return;
        }

        const recent = candles.slice(-lookback);
        const cons = detectConsolidation(recent, stdTh);
        const r = rangeFromCandles(recent);
        const vMA = volMA(candles, Math.min(40, candles.length));
        const lastClose = parseFloat(candle.c);
        const lastVol = parseFloat(candle.v);

        uiLog(`analyze: std=${cons.relativeStd.toFixed(6)} atr=${cons.relativeAtr.toFixed(6)} emaSpread=${cons.emaSpread.toFixed(6)}`);

        if(cons.consolidation){
          setSignal(`Consolidation detected. Range ${r.sup.toFixed(6)} - ${r.res.toFixed(6)}. mean=${cons.mean.toFixed(6)}`,'warn');
          localStorage.setItem('lastConsol_'+symbol, JSON.stringify({time:Date.now(), range:r, mean:cons.mean}));
        }

        const breakoutBuffer = 0.0005;
        const isBreakout = lastClose > r.res*(1+breakoutBuffer);
        const volConfirm = lastVol > Math.max(1.2*vMA, vMA + vMA*0.05);

        if(isBreakout && volConfirm){
          setSignal(`Breakout confirmed! Close ${lastClose.toFixed(6)} > resistance ${r.res.toFixed(6)} with vol ${Math.round(lastVol)} (vMA ${Math.round(vMA)})`,'ok');
        } else if(isBreakout && !volConfirm){
          setSignal(`Potential breakout (price). Volume not strong enough. lastVol ${Math.round(lastVol)} vMA ${Math.round(vMA)}`,'warn');
        }

      }catch(e){
        console.error('message handler error', e);
        uiLog('Message parse error (see console).');
      }
    };
  }

  function stop(){
    if(ws && ws.readyState === WebSocket.OPEN) {
      uiLog('Closing WS...');
      ws.close();
    } else {
      uiLog('No WS connection to close.');
    }
    running = false;
    setStatus('stopped','stopped');
  }

  document.getElementById('start').onclick = start;
  document.getElementById('stop').onclick = stop;

  // quick hint for the user
  uiLog('Detector loaded — click Start. Open DevTools → Console for more details.');
})();
</script>
</body>
</html>
